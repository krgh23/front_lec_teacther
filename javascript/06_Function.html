<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
<!--
    함수 작성 방법
    1. 함수 선언식    function 함수이름() {}
    2. 함수 표현식    const 변수명 = function() {}
    3. 화살표 표기법  const 변수명 = () => {}
-->

<!--
    함수 선언식
    1. 함수 이름을 결정해서 함수를 만드는 방식이다. (기명 함수 : 이름 있는 함수)
    2. 함수 선언식은 호이스팅(hoisting)이 되므로 존재하는 코드 Line 에 상관 없이 언제나 호출할 수 있다.
    3. 함수 선언식 예시
      // 함수 선언 (함수 만들기)
      function named() {
        본문
      }
      // 함수 호출 (함수 사용하기)
      named();
-->
<h4>함수 선언식</h4>
<script>
  // 함수 호출
  fnDeclare();
  // 함수 선언 (함수 선언은 호이스팅된다. 항상 먼저 처리된다.)
  function fnDeclare() {
    document.write('<div>fnDeclare</div>');
  }
</script>
<hr>

<!--
    함수 표현식
    1. 함수를 변수에 저장하는 방식이다.
    2. 주로 이름이 없는 익명 함수를 변수에 저장한다. (기명 함수도 함수 표현식이 가능하다.)
    3. 변수를 함수처럼 호출해서 사용할 수 있다.
    4. 함수 표현식은 호이스팅(hoisting)이 되지 않는다.
    5. 함수 표현식 예시
      1) 익명 함수
        // 함수 표현식 (함수를 만들어서 변수에 할당한다.)
        const expression = function() {
          본문
        }
        // 함수 호출 (함수를 사용한다.)
        expression();
      2) 기명 함수
        function named() {
          본문
        }
        const expression = named;
        expression();  또는  named();
-->
<h4>함수 표현식</h4>
<script>

  // 함수 표현식 (함수 표현식은 호이스팅 되지 않기 때문에 호출하기 전에 반드시 먼저 만들어야 한다.)
  const fnExpr = function() {
    document.write('<div>fnExpr</div>');
  }
  
  // 함수 호출
  fnExpr();

</script>
<hr>

<!--
    화살표 함수 표기법
    1. 함수 표현식의 간결한 대안이다.
    2. 약간의 의미적 차이와 의도적인 사용상 제한을 가지고 있다.
      1) 자체 바인딩이 this 에 포함되지 않는다.
      2) 객체를 생성하는 생성자로 사용할 수 없다.
      3) 객체에 포함된 메소드로 사용할 수 없다.
    3. 문법 특징
      1) 단일 매개변수인 경우 매개변수 소괄호()를 생략할 수 있다.
      2) 단일 실행문인 경우 본문 중괄호{}를 생략할 수 있다.
      3) 단일 return 인 경우 return 키워드 자체를 생략할 수 있다.
    4. 화살표 함수의 여러 예시들
      1) () => expression
      2) param => expression
      3) (param) => expression
      4) (param1, param2) => expression
      5) () => {
            statements
          }
      6) param => {
            statements
          }
      7) (param) => {
            statements
          }
      8) (param1, param2) => {
            statements
          }
-->
<h4>화살표 함수</h4>
<script>

  // 화살표 함수 표현식
  const fnArrow = () => {
    document.write('<div>fnArrow</div>');
  }

  // 함수 호출
  fnArrow();

</script>
<hr>

<!--
    함수의 중첩
    1. 함수 내부에 또 다른 함수를 선언할 수 있다.
    2. 외부 함수는 내부 함수의 변수를 사용할 수 없다.
    3. 내부 함수는 외부 함수의 변수를 사용할 수 있다.
-->

<!--
    인자와 매개변수
    1. 매개변수를 선언할 때 선언 키워드(var, let, const)는 사용하지 않는다.
    2. 모든 데이터(값, 배열, 객체, 함수 등)를 인자로 전달할 수 있다.
    3. 전개 구문(Spread Syntax)을 이용해 0개 이상의 인자를 처리할 수 있다.
    4. 인자가 전달되지 않는 경우에 사용할 디폴트 값을 지정할 수 있다.
-->

<!--
    콜백 함수
    1. 인자로 다른 함수에 전달된 함수를 의미한다.
    2. 함수1을 전달 받은 함수2는 본문에서 함수1을 다시 호출해야 하므로 "callback"이라고 한다.
    3. 함수 이름만 전달하거나 함수 자체를 전달한다.
-->

<!--
    반환
    1. 반환 값이 존재하더라도 반환타입은 작성하지 않는다.
    2. "return 값" 을 통해서 값을 반환할 수 있다.
    3. "return" 을 통해서 함수 실행을 종료할 수 있다.
-->

<!-- 문제1. checkWeight() 함수 구현하기 -->
<h4>checkWeight() 함수</h4>
<script>
  /*
    checkWeight() 함수
    1. 기능
      인자로 전달된 몸무게가 40 이상 90 미만이면 true, 40 미만이면 보호자의 동의 여부(confirm 이용), 90 이상이면 false 를 반환하는 함수
    2. 인자
      몸무게
    3. 반환
      boolean
  */

</script>
<hr>



<!-- 문제2. repeatDo() 함수 구현하기 -->
<h4>repeatDo() 함수</h4>
<script>
  /*
    repeatDo() 함수
    1. 기능
      첫 번째 인자로 전달한 함수를 두 번째 인자로 전달한 횟수만큼 반복 수행하는 함수
    1. 인자
      1) 실행할 함수
      2) 함수를 반복할 횟수
    2. 반환
      없음
  */

</script>
<hr>



<!-- 문제3. calculate() 함수 구현하기 -->
<h4>calculate() 함수</h4>
<script>
  /*
    calculate() 함수
    1. 기능
      첫 번째 인자로 전달한 함수를 이용해서 두 번째 인자와 세 번째 인자를 연산하고 그 결과를 반환하는 함수
    2. 인자
      1) 연산을 수행할 함수
      2) 연산을 수행할 값1
      3) 연산을 수행할 값2
    3. 반환
      연산 수행 결과 값
  */

</script>
<hr>

</body>
</html>